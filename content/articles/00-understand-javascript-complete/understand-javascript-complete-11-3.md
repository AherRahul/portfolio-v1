---
title: "How Typescript works?"
description: "Explore the behind-the-scenes journey of TypeScript compilation, from source code to JavaScript, with detailed insights into lexers, parsers, binders, checkers, and emitters."
datePublished: 2026-02-13
dateModified: 2026-02-13
topics:
  - javascript
courseName: 00-understand-javascript-complete
showOnArticles: false
featured: false
---

![image.png](https://res.cloudinary.com/duojkrgue/image/upload/v1758725512/Portfolio/javaScriptCourse/images/0_eestcm.png)


## Understanding TypeScript Compilation: From Code to JavaScript

<br />

## Introduction to TypeScript Compilation

TypeScript, a popular superset of JavaScript, relies on a complex compilation process to convert human-readable code into executable JavaScript. This process is analogous to translating spoken languages, involving multiple stages such as lexical analysis, parsing, binding, type checking, and code emission. Understanding these steps not only clarifies how TypeScript works under the hood but also aids developers in optimizing their code and troubleshooting errors efficiently.

<br />

## What Is Compilation?

Compilation is essentially the translation of one language into another. In the context of programming, it means converting high-level source code into low-level code such as bytecode or machine code. This process is similar to how linguists analyze and translate spoken languages like English or French. The TypeScript compiler (tsc) follows this same principle by transforming TypeScript source code into JavaScript, which browsers and runtimes can execute.

### Compilation vs. Interpretation

- **Bytecode Generation:** Some compilers stop at generating bytecode, which is then interpreted at runtime.
- **Machine Code Generation:** Other compilers generate machine code that the hardware can execute directly.

TypeScript primarily compiles to JavaScript, which is then executed by JavaScript engines in browsers or Node.js.



<br />

## The TypeScript Compilation Flow


![image.png](https://miro.medium.com/v2/resize:fit:720/format:webp/1*jfL4pMBAGjrWVRHUQksRDg.png)


To break down the compilation process, we will use the example source code:

```typescript
const a = "toto"
```

This simple line of code undergoes several distinct phases inside the TypeScript compiler:

### 1. Lexing (Tokenization)

The **Lexer** reads the raw source code, identifies meaningful atomic units called **tokens**, and passes them to the parser.


![image.png](https://miro.medium.com/v2/resize:fit:720/format:webp/1*FNv3WRQTR7VgGDpkCh1RSA.png)


#### What Are Tokens?

Tokens are the smallest elements in programming languages that carry meaning, similar to words in natural languages. In lexicography, a **lexical item** is a word or phrase that forms the basic vocabulary of a language. Likewise, tokens represent keywords, identifiers, operators, and literals in code.

> In lexicography, a lexical item is a single word, a part of a word, or a chain of words that forms the basic elements of a language’s lexicon (≈ vocabulary).
Lexical items are “natural units” translating between languages, or in learning a new language. - Wikipedia

##### Example Tokens from `const a = "toto"`:

- Keyword: `const`  
- Variable: `a`  
- Operator: `=`  
- Value: `"toto"`

This conversion from characters to tokens is crucial as it structures the input for further analysis.

### 2. Parsing

The **Parser** takes the tokens generated by the lexer and analyzes their syntactic structure, ensuring the code follows the language’s grammar rules.


![image.png](https://miro.medium.com/v2/resize:fit:640/format:webp/1*YCeT5Akcz_ckT0ksIGuhdw.png)

> In linguistics, syntax is the study of how words and morphemes combine to form larger units such as phrases and sentences. - Wikipedia

#### Abstract Syntax Tree (AST)

Parsing results in the creation of an **Abstract Syntax Tree** (AST), a hierarchical tree representation of the source code. The AST captures the relationships between language elements and their syntactic roles.

For example, the AST for `const a = "toto"` organizes the declaration, the identifier, and the value in a structured format, allowing the compiler to understand the code’s meaning and flow.



<br />

## Deep Dive into AST and SyntaxKind

TypeScript uses an internal enum called **SyntaxKind** to efficiently represent various kinds of syntax nodes in the AST. Each node is labeled by a numeric kind instead of a string for performance reasons.

```typescript
export const enum SyntaxKind {
    Unknown,          // 0
    EndOfFileToken,   // 1
    SingleLineCommentTrivia, // 2
    // ...
}
```

This optimization simplifies the compiler’s internal handling of code structures.



<br />

## 3. Binding: Creating the Symbols Table

After parsing, the compiler uses the **Binder** to generate a **Symbols table**. This table maps nodes in the AST to their corresponding symbols — essentially creating a dictionary of variables, functions, and other identifiers.


![image.png](https://miro.medium.com/v2/resize:fit:640/format:webp/1*wGZTgddxWD-c43vbH6dElw.png)


### Purpose of the Symbols Table

- Helps in tracking declarations and references.
- Optimizes the compiler’s ability to resolve names.
- Improves performance by avoiding redundant computations.

The symbols table acts as a central repository, linking code elements to their metadata, which aids later stages like type checking.



<br />

## 4. Type Checking with the Checker

The **Checker** component consumes the AST and the symbols table to perform **type checking**. This stage verifies that the code adheres to TypeScript’s static typing rules, ensuring variables are used consistently with their declared types.


![image.png](https://miro.medium.com/v2/resize:fit:720/format:webp/1*pwdZ64uyFAhJk_9QX42qlw.png)


### Handling Errors

The checker flags errors such as:

- Syntax errors
- Type mismatches
- Configuration file errors

Each error is associated with a specific build result flag, enabling precise diagnostics during compilation.

```typescript
enum BuildResultFlags {
    None = 0,
    Success = 1 << 0,
    ConfigFileErrors = 1 << 2,
    SyntaxErrors = 1 << 3,
    TypeErrors = 1 << 4,
    // ...
}
```

This system helps developers quickly pinpoint and resolve issues.



<br />

## 5. Emission: Generating JavaScript Code

The final step in the TypeScript compilation process is **emission**. The **Emitter** takes the fully validated AST and produces JavaScript code that can be executed by browsers or Node.js.

![image.png](https://miro.medium.com/v2/resize:fit:720/format:webp/1*GGE5mLoIUfsaYp6Z3uBxPg.png)


### Why Emit JavaScript?

TypeScript itself cannot run natively in browsers or most environments. Emitting JavaScript ensures compatibility while preserving the developer experience of static typing and advanced language features.



<br />

## Why Use Additional Tooling Beyond TypeScript?

While the TypeScript compiler can produce JavaScript directly, many projects incorporate additional tools such as bundlers and transpilers. This is because:

- TypeScript’s `target` option can only transpile to specific ECMAScript versions but does not optimize for browser compatibility.
- Bundlers like Webpack or Rollup help package code efficiently.
- Transpilers like Babel allow support for experimental ECMAScript features or optimize code for older browsers.

These tools complement the TypeScript compiler to enhance performance, compatibility, and maintainability.


<br />

## Summary

The TypeScript compilation process is a multi-stage pipeline that transforms human-friendly source code into executable JavaScript:

1. **Lexing:** Tokenizes the source code.
2. **Parsing:** Builds the Abstract Syntax Tree.
3. **Binding:** Creates a symbol table linking identifiers.
4. **Checking:** Performs type checks and error detection.
5. **Emitting:** Generates JavaScript output.

Understanding this flow empowers developers to write better code, debug efficiently, and grasp the rationale behind using supplementary build tools.



<br />

## FAQ

**Q1: What is the difference between a lexer and a parser?**  
A lexer breaks the source code into tokens, while a parser analyzes those tokens to check syntax and build the AST.

**Q2: Why does TypeScript generate JavaScript instead of machine code?**  
Because JavaScript is the language supported by browsers and many environments, TypeScript compiles to JavaScript for compatibility.

**Q3: What role does the symbols table play?**  
It maps identifiers to their declarations and types, aiding name resolution and type checking.

**Q4: Can TypeScript handle all JavaScript versions?**  
TypeScript can target specific ECMAScript versions but often requires additional tools to optimize for browsers and environments.


This comprehensive guide demystifies the TypeScript compiler's inner workings, offering insights for developers aiming to master their toolchain and improve software quality.